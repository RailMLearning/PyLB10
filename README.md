Лабораторная работа 10

Нуриахметов Раиль 501618 P3121

Результаты замеров при помощи модуля timeit при различном числе итераций
<img width="597" height="186" alt="изображение" src="https://github.com/user-attachments/assets/c9e6be05-93a1-4af2-9fa5-03f4a4ea6ec8" />
При линейном увелличении количества итераций, линейно увеличивается время выполнения.

Результаты замеров времени выполнения при использования многопточности
<img width="619" height="258" alt="изображение" src="https://github.com/user-attachments/assets/97fbeda6-a654-47c1-8d65-79e28581e321" />
Время выполнения базовой функции меньше чем время выполнения этой же функции, только в многопоточности. Можно сделать вывод, что для вычислительных задач многопоточность неэффективна.

Результаты тестирования процессов
<img width="659" height="256" alt="изображение" src="https://github.com/user-attachments/assets/8d5edcb0-f781-48c6-8b5d-2dca59766b1f" />
В отличии от потоков, при увеличении количества ядер, время выполнения существенно сокращается, за счёт того что у каждого процесса свой GIL.

Результат тестирования Cython
<img width="619" height="149" alt="изображение" src="https://github.com/user-attachments/assets/0f8689ac-5c05-472c-9397-9ae81a88c23f" />
Засчёт компиляции в языке C мы получаем кратное ускорение вычислений.

Результаты тестирования без GIL
<img width="573" height="273" alt="изображение" src="https://github.com/user-attachments/assets/971e4a0e-c7aa-4576-b171-039c9f9eaabe" />
Cython даёт кратное ускорение по сравнению с Python. Потоки под GIL неэффективны, процессы ускоряют за счёт отдельного GIL, но имеют большой оверхед. Использование Cython с noGIL позволяет реально распараллелить вычисления потоками и получить наилучшее время выполнения

