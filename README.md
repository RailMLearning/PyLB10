Лабораторная работа 10

Нуриахметов Раиль 501618 P3121

Результаты замеров при помощи модуля timeit при различном числе итераций
<img width="597" height="186" alt="изображение" src="https://github.com/user-attachments/assets/c9e6be05-93a1-4af2-9fa5-03f4a4ea6ec8" />
При линейном увелличении количества итераций, линейно увеличивается время выполнения.

Результаты замеров времени выполнения при использования многопточности
<img width="619" height="258" alt="изображение" src="https://github.com/user-attachments/assets/97fbeda6-a654-47c1-8d65-79e28581e321" />
Время выполнения базовой функции меньше чем время выполнения этой же функции, только в многопоточности. Можно сделать вывод, что для вычислительных задач многопоточность неэффективна.

Результаты тестирования процессов
<img width="659" height="256" alt="изображение" src="https://github.com/user-attachments/assets/8d5edcb0-f781-48c6-8b5d-2dca59766b1f" />
В отличии от потоков, при увеличении количества ядер, время выполнения существенно сокращается, за счёт того что у каждого процесса свой GIL.

Результат тестирования Cython
<img width="619" height="149" alt="изображение" src="https://github.com/user-attachments/assets/0f8689ac-5c05-472c-9397-9ae81a88c23f" />
Засчёт компиляции в языке C мы получаем кратное ускорение вычислений.

Результаты тестирования без GIL
<img width="573" height="273" alt="изображение" src="https://github.com/user-attachments/assets/971e4a0e-c7aa-4576-b171-039c9f9eaabe" />
Cython даёт кратное ускорение по сравнению с Python. Потоки под GIL неэффективны, процессы ускоряют за счёт отдельного GIL, но имеют большой оверхед. Использование Cython с noGIL позволяет реально распараллелить вычисления потоками и получить наилучшее время выполнения

Вывод:
Результаты тестирования
<img width="494" height="363" alt="изображение" src="https://github.com/user-attachments/assets/451ef15f-fe68-4107-803a-e5eacbaf12a5" />
Python (базовый) — самый медленный вариант, время растёт линейно с числом итераций.

Потоки под GIL не дают ускорения для вычислительных задач, а иногда даже медленнее из‑за накладных расходов.

Процессы позволяют распараллелить работу, так как у каждого процесса свой GIL, но накладные расходы на создание и коммуникацию делают их выгодными только при очень больших нагрузках.

Cython даёт кратное ускорение даже в одном потоке за счёт компиляции в C.

Cython с noGIL позволяет эффективно использовать потоки: при 6 потоках время снижается почти до 0.01 сек, что значительно быстрее процессов и даёт реальное масштабирование.

В Python 3.14 планируется опциональное отключение GIL (free-threaded Python). Это означает, что многопоточность сможет работать параллельно без необходимости использовать процессы или уходить в Cython. Для вычислительных задач это станет серьёзным шагом вперёд: код на чистом Python сможет масштабироваться по потокам, как сейчас это делает Cython с noGIL.
